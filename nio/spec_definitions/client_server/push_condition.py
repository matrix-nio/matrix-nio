# generated by datamodel-codegen:
#   filename:  push_condition.yaml
#   timestamp: 2024-06-01T22:41:36+00:00

from __future__ import annotations

from typing import Optional, Union

from pydantic import BaseModel, Field


class PushCondition(BaseModel):
    kind: str = Field(
        ...,
        description="The kind of condition to apply. See [conditions](/client-server-api/#conditions) for\nmore information on the allowed kinds and how they work.",
    )
    key: Optional[str] = Field(
        None,
        description="Required for `event_match`, `event_property_is` and `event_property_contains`\nconditions. The dot-separated field of the event to match.\n\nRequired for `sender_notification_permission` conditions. The field in\nthe power level event the user needs a minimum power level for. Fields\nmust be specified under the `notifications` property in the power level\nevent's `content`.",
        examples=["content.body"],
    )
    pattern: Optional[str] = Field(
        None,
        description="Required for `event_match` conditions. The [glob-style pattern](/appendices#glob-style-matching)\nto match against.",
    )
    is_: Optional[str] = Field(
        None,
        alias="is",
        description="Required for `room_member_count` conditions. A decimal integer\noptionally prefixed by one of, ==, <, >, >= or <=. A prefix of < matches\nrooms where the member count is strictly less than the given number and\nso forth. If no prefix is present, this parameter defaults to ==.",
    )
    value: Optional[Union[str, int, bool]] = Field(
        None,
        description="Required for `event_property_is` and `event_property_contains` conditions.\nA non-compound [canonical JSON](/appendices#canonical-json) value to match\nagainst.",
    )
